#include <iostream>
#include <array>


class Test {
public:
	auto callback() {
		return [this](int new_data) { // лямбда ни какого отношения не имеют к этому классу, поэтому нет доступа к полям в private, поэтому
							// чтобы как-то обратится к этому полю, то надо в лямбда передать объект this. поэтому this в списке захвата
			sensetive_data = new_data;
			// this->sensetive_data = new_data;
		};
	}
	auto callback_() {
		return [*this]() { // В С++17 появился такой способ захвата, т.е. захват его по значение. Т.е. в лямбда появляется
									   // копия this, мы не работаем с оригинальным this. Это один из способов, чтобы не было UB.
			std::cout << sensetive_data << std::endl;
		};
	}
private:
	int sensetive_data;
};


int main(int argc, const char* argv[]) {

	auto callback = Test{}.callback();	// создаём временный объект и вызываем его метод, и в этом методе захватываем this (указатель 
										// на объект, который вызвал этот метод). Соответственно временный объект будет жить до ;

	//............async(callback)    (выполняем какуе-то асинхронную операцию)

	// и вызывая тут колбек, то мы будем пытаться работать с this, который уже разрушился. 
	// callback();  // и тут попытаемся вызвать колбек, и это приведёт к UB

	// Поэтому объекты 'указатели', объекты 'ссылки' в лямбда не захватывать!!! Старайтесь захватывать по значению!

	int div{ 3 };

	[div_ = div + 10]() { // создаём новую переменную в контексте лямбда и инициализируем её
		std::cout << "div_ = " << div_ << std::endl;
	}();


	system("pause");
	return 0;
}