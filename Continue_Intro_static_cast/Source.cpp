#include <iostream>


class A {

};


class B : public A {
public:
	void test() {
		std::cout << a << std::endl;
	}
private:
	int a{ 10 };
};

class C : public A {

};

void func(A& a) {
	B& b = static_cast<B&>(a);  // здесь так называемый нестабильный интерфейс, т.е. мы не можем гарантировать, что точно заходит объект b
								// и это есть compile time, т.е. компилятор проверяет если ли он может преобразовать А в В, то он это делает  
	b.test();					// но так как этот объект (A& a) говорит, что у меня что-то является runtime, так как это ссылка или указатель,
}								// я могу ссылатся на что угодно. Поэтому здесь (B& b = static_cast<B&>(a)) надо получить гарантию runtime


int main(int argc, const char *argv[]) {

	B b;
	A a{b};  // восходящее преобразование  (объект производного класса преобразовывается в объект базового класса)
	
	// B b1{ a };  // нисходящие преобразование   (здесь некоторые компиляторы ругаются)
		

	C c;
	A& a1{ c };  // тут даём гарантию, что а1 всегда будет ссылатся на маленький кусок в c 
	
	// B& b2{ a1 };  //  error (UB)   здесь не даём гарантии, ибо a1 может ссылатся на другой какойто производный класс (например С)


	func(b);
	// func(c);  // UB


	system("pause");
	return 0;
}